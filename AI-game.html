<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>å­¦æ ¡æŠ—äº‰RTSï¼šé“è·¯ãƒ»CPUãƒ©ãƒ³ãƒ€ãƒ ãƒ»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡æ®ãƒ»å‹ãƒ»åˆ¶åœ§è‰²ç¶™æ‰¿</title>
<style>
  :root{
    --bg:#0f1220; --panel:#171a2b; --text:#e8ecf1; --muted:#9aa3b2;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px 10px 20px;
  }
  h1{font-size:16px; font-weight:700; margin:6px 0 0; color:#cfe4ff}
  .row{width:100%; max-width:980px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between}
  .panel{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    background:var(--panel); padding:8px 10px; border-radius:12px; box-shadow:0 0 0 1px #1f2440 inset;
  }
  button, select, input[type="range"]{
    background:#202746; color:var(--text); border:1px solid #2b345f; border-radius:10px; padding:6px 10px;
  }
  button:hover{filter:brightness(1.1); cursor:pointer}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; background:#1b203a; border:1px solid #2b345f}
  .dot{width:10px;height:10px;border-radius:50%}
  .stat{background:var(--panel); padding:6px 10px; border-radius:10px; color:#9aa3b2; font-size:12px}
  canvas{background:#0b0e1a; border-radius:14px; box-shadow:0 0 0 1px #1f2440 inset; display:block}
  footer{color:#7f8aa3; font-size:12px; opacity:.85}
  .legend-col{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
</style>
</head>
<body>
  <div class="row">
    <div class="panel">
      <button id="toggle">â¸ï¸ ä¸€æ™‚åœæ­¢</button>
      <label>é€Ÿåº¦Ã—<span id="speedLabel">1.0</span>
        <input id="speed" type="range" min="0.2" max="3" value="1" step="0.1" style="vertical-align:middle;width:140px">
      </label>
      <button id="reset">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
    <div class="panel">
      <label>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ ¡ï¼š
        <select id="playerTeam"></select>
      </label>
      <span id="order" class="badge">æŒ‡ç¤ºå…ˆï¼š-</span>
    </div>
  </div>

  <div class="row">
    <div class="panel legend-col" id="legend"></div>
  </div>

  <h1>å­¦æ ¡æŠ—äº‰ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é™£å–ã‚Šï¼ˆé“è·¯ï¼ãƒ©ãƒ³ãƒ€ãƒ CPUï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡æ®ï¼å‹ï¼åˆ¶åœ§è‰²ç¶™æ‰¿ï¼‰</h1>
  <canvas id="game" width="960" height="600"></canvas>
  <div id="stats" class="stat">ãƒ¦ãƒ‹ãƒƒãƒˆæ•°: â€¦</div>
  <footer>å­¦æ ¡ã‚’ã‚¯ãƒªãƒƒã‚¯ã§**é€²è»å…ˆã‚’æŒ‡ç¤º**ã§ãã¾ã™ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ ¡ã®ã¿ï¼‰ã€‚å‹ï¼ˆæ”»æ’ƒ/é˜²å¾¡/ãƒãƒ©ãƒ³ã‚¹/ä¸‡èƒ½ï¼‰ã®è£œæ­£ãŒã‹ã‹ã‚Šã¾ã™ã€‚</footer>

<script>
(() => {
  // ====== åŸºæœ¬è¨­å®š ======
  const CFG = {
    canvasW: 960, canvasH: 600,
    schoolRadius: 48,
    captureThreshold: 12,    // å æ‹ å¿…è¦ã€Œç´”æ»åœ¨ã€ç§’
    captureRate: 1.05,       // 1äººã§ã®ç§’ã‚ãŸã‚Šé€²è¡Œ
    decayRate: 1.6,          // æ‰€æœ‰å´ã®æŠ¼ã—æˆ»ã—
    baseSpawnInterval: 2.6,  // ã‚¹ãƒãƒ¼ãƒ³åŸºæº–
    maxUnitsPerTeam: 60,
    roadWidth: 10,           // é“ã®è¦‹ãŸç›®ç”¨
    unit: {
      speed: 60,             // px/sï¼ˆåŸºç¤å€¤ï¼‰
      sight: 85,
      engageDist: 14,
      hp: 100,
      dps: 22
    },
    cpuRetargetMin: 8,       // CPUãŒé€²è»å…ˆã‚’å†æŠ½é¸ã™ã‚‹é–“éš”ï¼ˆç§’ï¼‰
    cpuRetargetMax: 14
  };

  // ====== ãƒãƒ¼ãƒ  & å­¦æ ¡ å®šç¾© ======
  // å„æ ¡ã«ã€Œå‹ã€ã‚¢ãƒ¼ã‚­ã‚¿ã‚¤ãƒ—ã‚’ä»˜ä¸ï¼šæ”»æ’ƒ/é˜²å¾¡/ãƒãƒ©ãƒ³ã‚¹/ä¸‡èƒ½
  const ARCH = {
    æ”»æ’ƒå‹:   { hp:0.9, dps:1.25, speed:1.05, spawn:0.95, defense:0.95, decay:0.95 },
    é˜²å¾¡å‹:   { hp:1.25,dps:0.9,  speed:0.95, spawn:1.05, defense:1.2,  decay:1.15 },
    ãƒãƒ©ãƒ³ã‚¹å‹:{ hp:1.0, dps:1.0,  speed:1.0,  spawn:1.0,  defense:1.0,  decay:1.0  },
    ä¸‡èƒ½å‹:   { hp:1.1, dps:1.1,  speed:1.05, spawn:0.95, defense:1.05, decay:1.05 },
  };

  const TEAMS = [
    { id:0, name:"ç´…é™½é«˜æ ¡", color:"#f14b4b", archetype:"æ”»æ’ƒå‹" },
    { id:1, name:"è’¼å¶ºé«˜æ ¡", color:"#4b8bf1", archetype:"é˜²å¾¡å‹" },
    { id:2, name:"ç¿ æ „é«˜æ ¡", color:"#36c07f", archetype:"ãƒãƒ©ãƒ³ã‚¹å‹" },
    { id:3, name:"é»„ç¿”é«˜æ ¡", color:"#f1c24b", archetype:"ä¸‡èƒ½å‹" },
  ];

  // ====== é“è·¯ã‚°ãƒ©ãƒ• ======
  // è§’ï¼ˆå­¦æ ¡ï¼‰ï¼‹ä¸­å¤®ï¼‹åå­—ãƒãƒ¼ãƒ‰ã‚’ç”¨æ„ã—ã€å…¨ãƒ«ãƒ¼ãƒˆã¯ãƒãƒ¼ãƒ‰åˆ—ã®æœ€çŸ­çµŒè·¯ã§é€²è¡Œ
  const ROAD_NODES = [
    // 0-3: å­¦æ ¡ãƒãƒ¼ãƒ‰ï¼ˆåº§æ¨™ã¯å¾Œã§åˆæœŸåŒ–æ™‚ã«ä¸Šæ›¸ãï¼‰
    {id:0,x:120,y:120}, {id:1,x:840,y:120}, {id:2,x:120,y:480}, {id:3,x:840,y:480},
    // 4-8: ä¸­å¤®åå­—
    {id:4,x:480,y:120}, {id:5,x:480,y:300}, {id:6,x:480,y:480}, {id:7,x:120,y:300}, {id:8,x:840,y:300},
  ];
  const ROAD_EDGES = [
    [0,4],[4,1], // ä¸Šè¾ºæ¨ª
    [2,6],[6,3], // ä¸‹è¾ºæ¨ª
    [7,5],[5,8], // ä¸­å¤®æ¨ª
    [4,5],[5,6], // ç¸¦ä¸­å¤®
    [0,7],[2,7], // å·¦ç¸¦
    [1,8],[3,8], // å³ç¸¦
    // æ–œã‚ï¼ˆå¯¾è§’ã®è¿‘é“ï¼‰
    [0,5],[1,5],[2,5],[3,5]
  ];

  // ========= ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =========
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

  // Dijkstraï¼ˆå°è¦æ¨¡ã‚°ãƒ©ãƒ•ãªã®ã§ç´ æœ´å®Ÿè£…ï¼‰
  function shortestPath(nodes, edges, startId, goalId){
    const N = nodes.length;
    const adj = Array.from({length:N},()=>[]);
    for(const [a,b] of edges){
      const na = nodes[a], nb = nodes[b];
      const w = Math.hypot(na.x-nb.x, na.y-nb.y);
      adj[a].push({to:b,w}); adj[b].push({to:a,w});
    }
    const D=Array(N).fill(Infinity), prev=Array(N).fill(-1), used=Array(N).fill(false);
    D[startId]=0;
    for(let _=0;_<N;_++){
      let v=-1; let best=Infinity;
      for(let i=0;i<N;i++){ if(!used[i] && D[i]<best){best=D[i]; v=i;} }
      if(v===-1) break;
      used[v]=true;
      for(const e of adj[v]){
        if(D[e.to] > D[v]+e.w){ D[e.to]=D[v]+e.w; prev[e.to]=v; }
      }
    }
    if(D[goalId]===Infinity) return [];
    const path=[goalId]; let cur=goalId;
    while(prev[cur]!==-1){ cur=prev[cur]; path.push(cur); }
    path.reverse();
    return path.map(i=>nodes[i]);
  }

  // ========= ãƒ¢ãƒ‡ãƒ« =========
  class Unit {
    constructor(team, x, y, mods){
      this.team = team;
      this.x = x; this.y = y;
      this.hpMax = CFG.unit.hp * mods.hp;
      this.hp = this.hpMax;
      this.dps = CFG.unit.dps * mods.dps;
      this.speed = CFG.unit.speed * mods.speed;
      this.sight = CFG.unit.sight;
      this.engageDist = CFG.unit.engageDist;
      this.r = 5.5;
      this.path = [];    // é“ãƒãƒ¼ãƒ‰åˆ—ï¼ˆ{x,y}é…åˆ—ï¼‰
      this.pathIdx = 0;
      this.targetEnemy = null;
    }
    setPath(pathNodes){
      this.path = pathNodes.map(n=>({x:n.x,y:n.y}));
      this.pathIdx = 0;
    }
    update(dt, world){
      if(this.hp<=0) return;

      // ç´¢æ•µ â†’ äº¤æˆ¦
      const nearEnemy = world.findNearestEnemy(this);
      if(nearEnemy && dist(this,nearEnemy) <= this.sight){
        this.targetEnemy = nearEnemy;
      } else if(this.targetEnemy && this.targetEnemy.hp<=0){
        this.targetEnemy = null;
      }
      if(this.targetEnemy && dist(this,this.targetEnemy) <= this.engageDist){
        // é˜²è¡›ãƒœãƒ¼ãƒŠã‚¹ï¼šå­¦æ ¡å††å†…ã«ã„ã‚‹å´ã«é˜²å¾¡è£œæ­£
        const defBonusA = world.defenseBonusAt(this);
        const defBonusB = world.defenseBonusAt(this.targetEnemy);
        // äº’ã„ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆç›¸æ‰‹ã«ä¸ãˆã‚‹ï¼è‡ªåˆ†ã®DPS Ã— ç›¸æ‰‹ã®è¢«ãƒ€ãƒ¡å€ç‡ï¼‰
        this.targetEnemy.hp -= this.dps * dt * defBonusB; // ç›¸æ‰‹ãŒå®ˆå‹¢ãªã‚‰æ¸›ã‚Šã«ãã„
        this.hp            -= this.targetEnemy.dps * dt * defBonusA;
        return;
      }

      // çµŒè·¯ã«æ²¿ã£ã¦ç§»å‹•ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆå­¦æ ¡ã«ç´ã¥ãé“è·¯æœ€çŸ­è·¯ï¼‰
      if(!this.path || this.path.length===0){
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼/CPUã®ãƒãƒ¼ãƒ ç›®æ¨™ã‚’åæ˜ ã—ã¦çµŒè·¯å†è¨ˆç®—
        world.assignPathToTarget(this);
      }
      const p = this.path[this.pathIdx];
      if(p){
        const dx = p.x - this.x, dy = p.y - this.y;
        const d = Math.hypot(dx,dy);
        if(d < 4){ // æ¬¡ãƒãƒ¼ãƒ‰ã¸
          this.pathIdx++;
        } else {
          const v = this.speed * world.speed;
          this.x += (dx/d) * v * dt;
          this.y += (dy/d) * v * dt;
        }
      } else {
        // ç›®æ¨™å­¦æ ¡ã¸ç›´é€²ï¼ˆæœ€çµ‚åˆ°é”ï¼‰
        const tgt = world.getTeamTargetSchool(this.team) ?? world.findFallbackEnemySchool(this.team);
        if(tgt){
          const dx=tgt.x-this.x, dy=tgt.y-this.y, d=Math.hypot(dx,dy);
          if(d>0.0001){
            const v=this.speed*world.speed;
            this.x += (dx/d)*v*dt;
            this.y += (dy/d)*v*dt;
          }
        }
      }

      // ç”»é¢å¤–è£œæ­£
      this.x = clamp(this.x, 8, world.w-8);
      this.y = clamp(this.y, 8, world.h-8);
    }
    draw(g, color){
      g.fillStyle = color;
      g.beginPath(); g.arc(this.x, this.y, this.r, 0, Math.PI*2); g.fill();
      // HPãƒãƒ¼
      const w=14, h=3;
      g.fillStyle = "#00000066";
      g.fillRect(this.x - w/2, this.y - 10, w, h);
      const ratio = clamp(this.hp / this.hpMax, 0, 1);
      g.fillStyle = "#ffffffb0";
      g.fillRect(this.x - w/2, this.y - 10, w*ratio, h);
    }
  }

  class School {
    constructor(teamDef, x, y){
      this.name = teamDef.name;
      this.color = teamDef.color;
      this.x = x; this.y = y;
      this.owner = teamDef.id;
      this.capture = 0;
      this.archetype = teamDef.archetype;
      this.spawnBase = CFG.baseSpawnInterval;
      this.spawnTimer = rand(0, this.spawnIntervalForOwner()); // åˆå›ã°ã‚‰ã‘
    }
    spawnIntervalForOwner(){
      const mods = archMods(this.owner);
      return this.spawnBase * mods.spawn;
    }
    update(dt, world){
      // ã‚¹ãƒãƒ¼ãƒ³
      this.spawnTimer -= dt * world.speed;
      const myCount = world.countUnits(this.owner);
      if(this.spawnTimer <= 0 && myCount < CFG.maxUnitsPerTeam){
        world.spawnUnit(this.owner, this.x + rand(-18,18), this.y + rand(-18,18));
        this.spawnTimer += this.spawnIntervalForOwner();
      }

      // å æ‹ ãƒ­ã‚¸ãƒƒã‚¯
      const attackers = world.units.filter(u => u.team!==this.owner && dist(u,this)<=CFG.schoolRadius);
      const defenders = world.units.filter(u => u.team===this.owner && dist(u,this)<=CFG.schoolRadius);

      const T = CFG.captureThreshold;
      if(attackers.length>0 && defenders.length===0){
        // æ•µã®ã¿ â†’ ã‚²ãƒ¼ã‚¸ã¯æ•µæ–¹å‘ã¸é€²ã‚€
        this.capture -= CFG.captureRate * world.speed * dt * attackers.length;
      } else {
        // æŠ¼ã—æˆ»ã—ï¼ˆæ‰€æœ‰ãƒãƒ¼ãƒ ã®ã€Œé˜²å¾¡å‹ã€ç­‰ã«ã‚ˆã‚Šå¼·ããªã‚‹ï¼‰
        const decay = CFG.decayRate * archMods(this.owner).decay;
        if(this.capture < 0){
          this.capture = Math.min(0, this.capture + decay * world.speed * dt);
        } else if (this.capture > 0){
          this.capture = Math.max(0, this.capture - decay * world.speed * dt);
        }
      }

      // é–¾å€¤ã‚’è¶…ãˆãŸã‚‰æ‰€æœ‰è€…åˆ‡æ›¿ï¼ˆï¼åˆ¶åœ§è‰²ç¶™æ‰¿ï¼‰
      if(this.capture <= -T){
        const newOwner = this.getStrongestAttackerTeam(world) ?? this.owner;
        this.owner = newOwner;
        this.color = world.palette[newOwner].fill; // è‰²ã‚’åˆ¶åœ§å´ã«åˆã‚ã›ã‚‹
        this.capture = 0;
        // ãƒªã‚¹ãƒãƒ¼ãƒ³é–“éš”ã‚‚æ–°é™£å–¶ã®å‹ã§å¤‰ã‚ã‚‹
        this.spawnTimer = this.spawnIntervalForOwner();
      }
    }
    getStrongestAttackerTeam(world){
      const counts = new Map();
      for(const u of world.units){
        if(u.team===this.owner) continue;
        if(dist(u,this)<=CFG.schoolRadius){
          counts.set(u.team, (counts.get(u.team)||0)+1);
        }
      }
      let best=null, bestN=-1;
      for(const [team,n] of counts){
        if(n>bestN){bestN=n; best=team;}
      }
      return best;
    }
    draw(g, palette){
      // æ‰€æœ‰è‰²ã®æœ¬ä½“
      g.beginPath();
      g.fillStyle = palette[this.owner].fill;
      g.strokeStyle = "#00000055";
      g.lineWidth = 2;
      g.arc(this.x, this.y, CFG.schoolRadius, 0, Math.PI*2);
      g.fill(); g.stroke();

      // å­¦æ ¡åï¼‹å‹
      g.fillStyle="#0b0e1a"; g.font="700 13px system-ui, -apple-system";
      g.textAlign="center"; g.textBaseline="middle";
      g.fillText(`${this.name}`, this.x, this.y-6);
      g.font="600 11px system-ui, -apple-system";
      g.fillText(`(${this.archetype})`, this.x, this.y+10);

      // ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒªãƒ³ã‚°ã®ãƒªãƒ³ã‚°
      const ratio = clamp(Math.abs(this.capture)/CFG.captureThreshold, 0, 1);
      if(ratio>0){
        g.strokeStyle="#ffffffc0"; g.lineWidth=4;
        g.beginPath();
        g.arc(this.x, this.y, CFG.schoolRadius+6, -Math.PI/2, -Math.PI/2 + Math.PI*2*ratio);
        g.stroke();
      }
    }
  }

  // å‹è£œæ­£ã‚’å–å¾—
  function archMods(teamId){
    const arch = TEAMS[teamId]?.archetype ?? "ãƒãƒ©ãƒ³ã‚¹å‹";
    return ARCH[arch] ?? ARCH["ãƒãƒ©ãƒ³ã‚¹å‹"];
  }

  // ========= ãƒ¯ãƒ¼ãƒ«ãƒ‰ =========
  class World {
    constructor(canvas){
      this.canvas = canvas;
      this.g = canvas.getContext("2d");
      this.w = canvas.width; this.h = canvas.height;
      this.time = 0;
      this.speed = 1.0;
      this.running = true;

      this.units = [];
      this.schools = [];
      this.palette = TEAMS.map(t=>({fill:t.color}));
      this.teamTargetSchoolId = [1,2,3,0]; // å„ãƒãƒ¼ãƒ ã®ç¾åœ¨ã®é€²è»å…ˆï¼ˆåˆæœŸå€¤ï¼‰
      this.cpuTimers = [0,0,0,0];          // å†æŠ½é¸ã‚¿ã‚¤ãƒ
      this.playerTeam = 0;                 // UIã§å¤‰æ›´å¯èƒ½
    }
    setup(){
      this.units.length = 0;
      // å­¦æ ¡é…ç½®ï¼ˆè§’ï¼‰
      const s0 = new School(TEAMS[0], 120, 120);
      const s1 = new School(TEAMS[1], this.w-120, 120);
      const s2 = new School(TEAMS[2], 120, this.h-120);
      const s3 = new School(TEAMS[3], this.w-120, this.h-120);
      this.schools = [s0,s1,s2,s3];

      // ROAD_NODESã®0-3ã‚’å­¦æ ¡åº§æ¨™ã§ä¸Šæ›¸ã
      ROAD_NODES[0].x=s0.x; ROAD_NODES[0].y=s0.y;
      ROAD_NODES[1].x=s1.x; ROAD_NODES[1].y=s1.y;
      ROAD_NODES[2].x=s2.x; ROAD_NODES[2].y=s2.y;
      ROAD_NODES[3].x=s3.x; ROAD_NODES[3].y=s3.y;

      // åˆæœŸãƒ¦ãƒ‹ãƒƒãƒˆ
      for(let t=0;t<4;t++){
        for(let i=0;i<6;i++){
          const sc = this.schools[t];
          this.spawnUnit(t, sc.x+rand(-22,22), sc.y+rand(-22,22));
        }
      }

      // CPUå†æŠ½é¸ã‚¿ã‚¤ãƒåˆæœŸåŒ–
      for(let t=0;t<4;t++){
        this.cpuTimers[t] = rand(CFG.cpuRetargetMin, CFG.cpuRetargetMax);
      }
    }
    spawnUnit(team,x,y){
      const mods = archMods(team);
      const u = new Unit(team,x,y,mods);
      // é€²è»å…ˆã«åŸºã¥ãçµŒè·¯ã‚’è¨­å®š
      this.assignPathToTarget(u);
      this.units.push(u);
    }
    countUnits(team){
      return this.units.reduce((a,u)=>a+(u.team===team?1:0),0);
    }
    findNearestEnemy(u){
      let best=null, bestD=Infinity;
      for(const e of this.units){
        if(e===u || e.hp<=0 || e.team===u.team) continue;
        const d = Math.hypot(u.x-e.x, u.y-e.y);
        if(d<bestD){bestD=d; best=e;}
      }
      return best;
    }
    getTeamTargetSchool(team){
      const id = this.teamTargetSchoolId[team];
      if(id==null) return null;
      return this.schools[id];
    }
    findFallbackEnemySchool(team){
      // ä½•ã‚‰ã‹ã®ç†ç”±ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒç„¡åŠ¹ãªã‚‰æœ€ã‚‚è¿‘ã„æ•µæ ¡
      let best=null, bestD=Infinity;
      for(let i=0;i<this.schools.length;i++){
        const s=this.schools[i];
        if(s.owner === team) continue;
        const d=Math.hypot(s.x- this.schools[team].x, s.y- this.schools[team].y);
        if(d<bestD){bestD=d; best=s;}
      }
      return best;
    }
    assignPathToTarget(u){
      // æœ€å¯„ã‚Šã®é“è·¯ãƒãƒ¼ãƒ‰ï¼ˆå‡ºç™ºï¼‰ã¨ã€ç›®æ¨™å­¦æ ¡ã®ãƒãƒ¼ãƒ‰ï¼ˆ0-3ã®ã„ãšã‚Œã‹ï¼‰
      const startId = nearestNodeId(u.x,u.y);
      const tgtSchool = this.getTeamTargetSchool(u.team) ?? this.findFallbackEnemySchool(u.team);
      if(!tgtSchool) { u.setPath([]); return; }
      const goalId = this.schools.indexOf(tgtSchool); // 0-3ã«å¯¾å¿œ
      const path = shortestPath(ROAD_NODES, ROAD_EDGES, startId, goalId);
      u.setPath(path);
    }
    defenseBonusAt(u){
      // å­¦æ ¡å††å†…ã«ã„ã‚‹å ´åˆã€ãã®å­¦æ ¡ã®æ‰€æœ‰è€…å´ã«é˜²å¾¡è£œæ­£ï¼ˆè¢«ãƒ€ãƒ¡å€ç‡ã‚’ä¸‹ã’ã‚‹ï¼‰
      for(const s of this.schools){
        if(dist(u,s)<=CFG.schoolRadius){
          if(u.team === s.owner){
            return 1/ARCH[TEAMS[s.owner].archetype].defense; // é˜²å¾¡å‹ã»ã©å°ã•ããªã‚‹
          }
        }
      }
      return 1.0;
    }
    update(dt){
      // å­¦æ ¡/ãƒ¦ãƒ‹ãƒƒãƒˆæ›´æ–°
      for(const s of this.schools) s.update(dt, this);
      for(const u of this.units) u.update(dt, this);
      // æ­»äº¡é™¤å»
      this.units = this.units.filter(u=>u.hp>0);

      // CPUã‚¿ãƒ¼ã‚²ãƒ†ã‚£ãƒ³ã‚°ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä»¥å¤–ã®ãƒãƒ¼ãƒ ï¼‰
      for(let t=0;t<4;t++){
        if(t===this.playerTeam) continue;
        this.cpuTimers[t] -= dt * this.speed;
        if(this.cpuTimers[t] <= 0){
          this.retargRandom(t);
          this.cpuTimers[t] = rand(CFG.cpuRetargetMin, CFG.cpuRetargetMax);
        }
      }

      this.time += dt;
    }
    retargRandom(team){
      const enemies = this.schools
        .map((s,i)=>({s,i}))
        .filter(o=>o.s.owner!==team);
      if(enemies.length===0) return;
      const pick = enemies[Math.floor(Math.random()*enemies.length)].i;
      this.teamTargetSchoolId[team] = pick;
      // æ—¢å­˜ãƒ¦ãƒ‹ãƒƒãƒˆã«ã‚‚æ–°ãƒ«ãƒ¼ãƒˆã‚’å†ä»˜ä¸ï¼ˆè»½é‡åŒ–ã®ãŸã‚è¿‘å‚ã ã‘ã§ã‚‚å¯ã ãŒä»Šå›ã¯å…¨ä½“ï¼‰
      for(const u of this.units) if(u.team===team){ this.assignPathToTarget(u); }
    }
    drawRoads(){
      const g=this.g;
      g.save();
      // é“ã®ä¸‹åœ°
      g.strokeStyle="#202742";
      g.lineWidth = CFG.roadWidth+6;
      g.lineCap="round";
      g.lineJoin="round";
      g.beginPath();
      for(const [a,b] of ROAD_EDGES){
        const A=ROAD_NODES[a], B=ROAD_NODES[b];
        g.moveTo(A.x, A.y); g.lineTo(B.x, B.y);
      }
      g.stroke();
      // é“ã®æœ¬ä½“
      g.strokeStyle="#2a325b";
      g.lineWidth = CFG.roadWidth;
      g.beginPath();
      for(const [a,b] of ROAD_EDGES){
        const A=ROAD_NODES[a], B=ROAD_NODES[b];
        g.moveTo(A.x, A.y); g.lineTo(B.x, B.y);
      }
      g.stroke();
      g.restore();
    }
    draw(){
      const g=this.g;
      g.clearRect(0,0,this.w,this.h);

      // èƒŒæ™¯ã®è–„ã‚°ãƒªãƒƒãƒ‰
      g.save();
      g.strokeStyle="#141a2a"; g.lineWidth=1;
      for(let x=0;x<=this.w;x+=40){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,this.h); g.stroke(); }
      for(let y=0;y<=this.h;y+=40){ g.beginPath(); g.moveTo(0,y); g.lineTo(this.w,y); g.stroke(); }
      g.restore();

      // é“è·¯
      this.drawRoads();

      // é€²è»å…ˆãƒ©ã‚¤ãƒ³ï¼ˆå„ãƒãƒ¼ãƒ ã®ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰
      g.save();
      g.setLineDash([6,6]); g.lineWidth=2; g.strokeStyle="#ffffff33";
      for(let t=0;t<4;t++){
        const src = this.schools[t];
        const dst = this.schools[this.teamTargetSchoolId[t]];
        if(src && dst && src!==dst){
          g.beginPath(); g.moveTo(src.x,src.y); g.lineTo(dst.x,dst.y); g.stroke();
        }
      }
      g.restore();

      // å­¦æ ¡
      for(const s of this.schools) s.draw(g, this.palette);

      // ãƒ¦ãƒ‹ãƒƒãƒˆ
      for(const u of this.units){ u.draw(g, this.palette[u.team].fill); }
    }
  }

  // æœ€å¯„ã‚Šãƒãƒ¼ãƒ‰ID
  function nearestNodeId(x,y){
    let best=-1, bestD=Infinity;
    for(const n of ROAD_NODES){
      const d=Math.hypot(x-n.x,y-n.y);
      if(d<bestD){bestD=d; best=n.id;}
    }
    return best;
  }

  // ====== å®Ÿè¡Œéƒ¨ ======
  const canvas = document.getElementById("game");
  const world = new World(canvas);
  world.setup();

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if(world.running){
      world.update(dt);
      world.draw();
      updateStats();
    } else {
      world.draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ====== UI ======
  const $toggle = document.getElementById("toggle");
  const $speed = document.getElementById("speed");
  const $speedLabel = document.getElementById("speedLabel");
  const $reset = document.getElementById("reset");
  const $stats = document.getElementById("stats");
  const $playerTeam = document.getElementById("playerTeam");
  const $order = document.getElementById("order");
  const $legend = document.getElementById("legend");

  // ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é¸æŠ
  function setupLegend(){
    $legend.innerHTML = "";
    TEAMS.forEach(t=>{
      const span = document.createElement("span");
      span.className="badge";
      span.innerHTML = `<span class="dot" style="background:${t.color}"></span>${t.name}ï¼ˆ${t.archetype}ï¼‰`;
      $legend.appendChild(span);
    });
    $playerTeam.innerHTML = TEAMS.map(t=>`<option value="${t.id}">${t.name}</option>`).join("");
    $playerTeam.value = world.playerTeam;
  }
  setupLegend();

  function updateStats(){
    const counts = [0,0,0,0];
    for(const u of world.units) counts[u.team]++;
    const owners = world.schools.map(s=>s.owner);
    const ownerStr = owners.map(o=>TEAMS[o].name.replace("é«˜æ ¡","")).join(" / ");
    const target = world.getTeamTargetSchool(world.playerTeam);
    $stats.textContent = `ãƒ¦ãƒ‹ãƒƒãƒˆæ•°ï¼šç´…é™½ ${counts[0]}ï½œè’¼å¶º ${counts[1]}ï½œç¿ æ „ ${counts[2]}ï½œé»„ç¿” ${counts[3]}ã€€ï½œã€€æ‰€æœ‰ï¼š${ownerStr}`;
    $order.textContent = `æŒ‡ç¤ºå…ˆï¼š${target ? target.name : "-"}`;
  }

  $toggle.onclick = ()=>{
    world.running = !world.running;
    $toggle.textContent = world.running ? "â¸ï¸ ä¸€æ™‚åœæ­¢" : "â–¶ å†é–‹";
  };
  $speed.oninput = ()=>{
    world.speed = parseFloat($speed.value);
    $speedLabel.textContent = world.speed.toFixed(1);
  };
  $reset.onclick = ()=>{
    world.setup();
  };
  $playerTeam.onchange = ()=>{
    world.playerTeam = parseInt($playerTeam.value,10);
  };

  // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡ç¤º
  canvas.addEventListener("click",(e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«æœ€ã‚‚è¿‘ã„å­¦æ ¡ã‚’å–å¾—ï¼ˆåŠå¾„+20ä»¥å†…ï¼‰
    let targetId=-1, best=Infinity;
    world.schools.forEach((s,i)=>{
      const d=Math.hypot(x-s.x,y-s.y);
      if(d<best && d<=CFG.schoolRadius+20){ best=d; targetId=i; }
    });
    if(targetId>=0){
      // è‡ªåˆ†ã®å­¦æ ¡ä»¥å¤–ã‚’æŒ‡ç¤ºï¼ˆè‡ªé™£ã‚¯ãƒªãƒƒã‚¯ãªã‚‰ã‚¹ãƒ«ãƒ¼ï¼‰
      if(targetId !== world.playerTeam){
        world.teamTargetSchoolId[world.playerTeam] = targetId;
        for(const u of world.units) if(u.team===world.playerTeam){ world.assignPathToTarget(u); }
      }
    }
  });

  // ã‚­ãƒ¼æ“ä½œ
  window.addEventListener("keydown",(e)=>{
    if(e.code==="Space"){ e.preventDefault(); $toggle.click(); }
    if(e.key==="1"){ $speed.value="1"; $speed.oninput(); }
    if(e.key==="2"){ $speed.value="1.5"; $speed.oninput(); }
    if(e.key==="3"){ $speed.value="2.0"; $speed.oninput(); }
  });
})();
</script>
</body>
</html>